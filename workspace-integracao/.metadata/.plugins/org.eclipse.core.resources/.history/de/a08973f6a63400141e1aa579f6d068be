package com.fiap.contamedica.business;

import java.io.StringReader;
import java.io.StringWriter;
import java.util.Random;
import java.util.logging.Logger;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.stream.StreamSource;

import com.fiap.contamedica.entity.AnaliseConta;
import com.fiap.contamedica.entity.ContaMedica;

/**
 * Responsável em implementar o negócio da Analise de Conta.
 * 
 * @author Luiz Fernando 
 *
 */
public class AnaliseContaBusiness {
	
	private final static Logger log = Logger.getLogger(AnaliseContaBusiness.class.getName()); 
	
	public AnaliseContaBusiness() {}
	
	public String analisarConta(String xmlIn) {
		
		String xmlRetorno = "";
		
		ContaMedica contaMedica = parseXMLtoObject(xmlIn);
		AnaliseConta analiseConta = new AnaliseConta(new Random().nextInt());
		
		/* 
		 * IMPLEMENTAÇÃO DA REGRA DE NEGÓCIO
		 * No caso se houver divergência entre os valores informado e pago, 
		 * deverá haver a glosa e o envio de e-mail ao prestador notificando a divergência
		 * 
		 */
		if (contaMedica.getValorInformado().doubleValue() != contaMedica.getValorAcatado().doubleValue()) {
			// SE OS VALORES ESTIVEREM DIVERGENTES GERA A GLOSA E INFORMA O PRESTADOR
			enviarEmailPrestador(analiseConta);
			analiseConta.setResultadoAnalise("Ocorreu glosa na conta médica "+ contaMedica.getCodContaMedica() + " e o prestador foi informado no email: " + contaMedica.getEmailPrestador());
		} else {
			analiseConta.setResultadoAnalise("Conta Médica analisada com sucesso!");
		}
		
		xmlRetorno = parseObjetcToXML(analiseConta);
		
		return xmlRetorno;
	}
	
	/**
	 * @param analiseConta
	 */
	private void enviarEmailPrestador(AnaliseConta analiseConta) {
		

	}
	
	private String parseObjetcToXML(AnaliseConta analiseConta) {
		
		String xml = "";
		
		StringWriter stringWriter = new StringWriter();
		
		try {
			
			// CRIA UM CONTEXTO PARA O JAXB
			JAXBContext jc = JAXBContext.newInstance(AnaliseConta.class);
			
			// INSTANCIA DO OBJETO QUE IRÁ FAZER A CONVERSÃO
			Marshaller m = jc.createMarshaller();
			
			// COLOCANDO A PROPRIEDADE PARA DEIXAR FORMATADO O XML
			m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
			
			// FAZENDO O PARSE PARA UM StringWriter
			m.marshal(analiseConta, stringWriter);
			
			// PARSEANDO PARA UM STRING
			xml = stringWriter.toString();
			
		} catch (JAXBException e) {
			log.info("Erro ao fazer o parse do XML!");
			e.printStackTrace();
		}
		return xml;
	}

	/**
	 * Responsável em fazer o parse de um XML para um objeto
	 * 
	 * @param xmlOut
	 * @return
	 */
	private ContaMedica parseXMLtoObject(String xmlOut) {
		
		ContaMedica contaMedica = null;
		
		try {
			JAXBContext jc = JAXBContext.newInstance(ContaMedica.class);
			Unmarshaller unmarshaller = jc.createUnmarshaller();
			StreamSource streamSource = new StreamSource(new StringReader(xmlOut));
			JAXBElement<ContaMedica> je = unmarshaller.unmarshal(streamSource, ContaMedica.class);

			contaMedica = (ContaMedica) je.getValue();

		} catch (JAXBException e) {
			log.info("Erro ao fazer o parse do XML!");
			e.printStackTrace();
		}
		
		return contaMedica;
	}
}
